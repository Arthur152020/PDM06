Contexto do Projeto – Programação para Dispositivos Móveis (PDM)

Este arquivo define o padrão de código, estrutura e nomenclatura adotado pelo professor de PDM, baseado na análise do projeto-exemplo fornecido.

================================================================================
RESUMO DO ESTILO GERAL
================================================================================

Linguagem e Framework:
- React Native com Expo (~54.0.20)
- TypeScript (strict mode habilitado)
- React 19.1.0
- Axios para requisições HTTP

Arquitetura:
- Padrão MVVM (Model-View-ViewModel)
- Separação clara de responsabilidades entre camadas
- View: componentes de UI (components/)
- ViewModel: hooks customizados que orquestram lógica (viewmodel/)
- Model: entidades e serviços (model/entities/ e model/services/)

Estrutura Típica de Diretórios:
- source/
  - App.tsx (componente raiz)
  - components/ (componentes de UI/View)
  - model/
    - entities/ (interfaces/tipos TypeScript)
    - services/ (classes de serviço para acesso a dados)
  - viewmodel/ (hooks customizados que conectam Model e View)

Nomenclatura de Arquivos:
- Componentes: PascalCase.tsx (ex: PostList.tsx)
- Entidades: camelCase.ts (ex: post.ts)
- Serviços: camelCase.ts com sufixo Service (ex: postService.ts)
- ViewModels/Hooks: camelCase.ts com prefixo "use" (ex: usePosts.ts)
- Arquivo principal: App.tsx
- Entry point: index.ts na raiz

================================================================================
PADRÃO DE NOMENCLATURA E FUNÇÕES
================================================================================

Variáveis e Estados:
- camelCase para variáveis locais e estados
- Nomes descritivos e em português para textos de UI (ex: "Carregando", "Recarregar")
- Estados booleanos: loading, error (sem prefixo "is")
- Estados de dados: nome no plural quando for array (ex: posts)

Funções:
- camelCase para funções e métodos
- Funções assíncronas: async/await, retornam Promise tipada
- Métodos estáticos em serviços: static async nomeDoMetodo(): Promise<Tipo>
- Funções de ação: verbos simples (ex: refresh, getPosts)

Componentes:
- PascalCase para componentes React
- export default function NomeDoComponente() para componentes principais
- Arrow functions podem ser usadas, mas o professor prefere function declarations

Hooks Customizados:
- Prefixo "use" obrigatório (ex: usePosts)
- function useNomeDoHook(): TipoRetorno
- Retornam objeto com estado e ações: { estado1, estado2, acao1, acao2 }

Interfaces e Tipos:
- PascalCase para interfaces (ex: Post, UsePostsState, UsePostsActions)
- Interfaces exportadas explicitamente
- Tipos explícitos em todos os lugares (TypeScript strict)

Serviços:
- Classe com nome PascalCase + sufixo "Service" (ex: PostService)
- Métodos estáticos: static async nomeMetodo(): Promise<Tipo>
- Não instanciam objetos, são chamados diretamente: PostService.getPosts()

Convenções de Case:
- camelCase: variáveis, funções, métodos, hooks
- PascalCase: componentes, interfaces, classes, tipos
- kebab-case: não usado
- snake_case: não usado

================================================================================
ESTILO DE CÓDIGO E FORMATAÇÃO
================================================================================

Ordem dos Blocos no Arquivo:
1. Imports (React primeiro, depois React Native, depois imports locais)
2. Interfaces/Tipos (se houver, antes do componente/hook)
3. Componente/Hook principal
4. Estilos (StyleSheet.create no final)

Indentação e Espaçamento:
- 4 espaços para indentação (não tabs)
- Linha em branco entre blocos lógicos
- Linha em branco antes do return no JSX
- Espaçamento consistente em objetos e arrays

Declaração de Funções:
- function declarations para hooks customizados: export function useNome() { }
- export default function para componentes: export default function Componente() { }
- Arrow functions podem aparecer em callbacks, mas não como padrão principal

Hooks do React:
- useState: const [nome, setNome] = useState<Tipo>(valorInicial);
- useEffect: useEffect(() => { }, []);
- Tipagem explícita nos generics do useState
- Comentário eslint-disable quando necessário para dependências do useEffect

Async/Await:
- Sempre usar async/await, nunca .then()
- Funções assíncronas retornam Promise tipada
- Tratamento de erro com try/catch/finally
- setLoading(true) no início, setLoading(false) no finally

Estrutura de Componentes:
- Destructuring do hook no início: const { posts, loading, error, refresh } = usePosts();
- Early returns para estados de loading e error
- JSX com return explícito e parênteses
- Props tipadas quando necessário

Comentários:
- Comentários em português quando necessário
- Comentários de código desabilitado com // (ex: //await new Promise...)
- Comentários eslint-disable quando necessário
- Comentários explicativos no código quando a lógica não é óbvia

================================================================================
PADRÕES DE INTERFACE (UI)
================================================================================

Componentes React Native Mais Usados:
- View: container principal
- Text: exibição de texto
- ScrollView: para listas scrolláveis (no App.tsx)
- Button: botões de ação
- ActivityIndicator: spinner de carregamento
- StyleSheet: criação de estilos

Estrutura Típica de Cada Tela/Componente:
1. Imports
2. Declaração do componente com export default function
3. Uso do hook ViewModel (destructuring)
4. Early returns para estados especiais (loading, error)
5. JSX principal com View container
6. Mapeamento de arrays com .map()
7. StyleSheet.create no final

Nomes de Estilos:
- container: estilo principal do container
- containerSpinner: container para estado de loading
- card: estilo para cards/itens de lista
- title: estilo para títulos
- body: estilo para corpo de texto
- camelCase para todos os nomes de estilos

Formato dos Estilos:
- StyleSheet.create({ }) no final do arquivo
- Propriedades CSS-like: display, justifyContent, alignItems, flex, flexDirection
- Cores em formato string: '#f0f0f0', '#00ff00', '#555'
- Padding e margin em números simples: padding: 15, margin: 15
- Largura em string com porcentagem: width: '80%'
- borderRadius, fontSize, fontWeight conforme necessário
- shadowColor, shadowOffset, shadowOpacity, shadowRadius, elevation para sombras (Android/iOS)

Estrutura de Cards/Itens:
- View com estilo card
- Padding e margin consistentes
- borderRadius para cantos arredondados
- backgroundColor para fundo
- Sombra para profundidade visual
- Text com estilos title e body

Botões:
- Button nativo do React Native
- title em português: "Recarregar"
- onPress chama função do ViewModel

Estados de Loading:
- ActivityIndicator com size="large" e color específica
- Text "Carregando" abaixo do spinner
- Container centralizado (flex: 1, justifyContent: 'center', alignItems: 'center')

Estados de Erro:
- Text com mensagem de erro
- Button "Recarregar" que chama função refresh

================================================================================
BOAS PRÁTICAS E CONVENÇÕES ESPECÍFICAS DO PROFESSOR
================================================================================

Arquitetura MVVM:
- View (components/) nunca chama serviços diretamente
- ViewModel (viewmodel/) é o único ponto de comunicação entre View e Model
- Model (model/) não conhece View ou ViewModel
- Separação rigorosa de responsabilidades

Ordem Lógica das Funções:
- No ViewModel: estados primeiro (useState), depois funções auxiliares (refresh), depois useEffect, por fim return
- No componente: hook primeiro, depois early returns, depois JSX principal

Tratamento de Erros:
- Try/catch no ViewModel, não no serviço
- Mensagens de erro amigáveis em português: 'Erro ao carregar os posts'
- Estado error: string | null
- setError(null) antes de nova tentativa

Carregamento de Dados:
- loading inicial: true
- refresh() chamado no useEffect inicial para carregar automaticamente
- setLoading(true) no início de refresh
- setLoading(false) no finally

Tipagem TypeScript:
- Strict mode habilitado
- Tipos explícitos em todos os lugares
- Interfaces para estruturas de dados
- Generics tipados (useState<Post[]>, Promise<Post[]>)
- Interfaces separadas para estado e ações quando necessário

Imports:
- React importado explicitamente: import React from 'react';
- Componentes React Native importados individualmente
- Imports locais com caminhos relativos: '../viewmodel/usePosts'
- Ordem: React → React Native → imports locais

Navegação:
- ScrollView no App.tsx envolvendo o componente principal
- contentContainerStyle={{ flexGrow: 1 }} no ScrollView
- Espaçamento com View vazio quando necessário: <View style={{height: 80}}></View>

Comentários e Documentação:
- README.md em cada pasta explicando a responsabilidade da camada
- Comentários em português
- Comentários de código desabilitado mantidos para referência
- Documentação clara da arquitetura MVVM nos READMEs

Estrutura de Serviços:
- Classe com métodos estáticos
- Não precisa instanciar: PostService.getPosts()
- Retorna Promise tipada
- Axios para requisições HTTP
- URL da API hardcoded (não em variáveis de ambiente neste exemplo)

Estrutura de ViewModels/Hooks:
- Interface para estado: UsePostsState
- Interface para ações: UsePostsActions
- Retorno combinado: UsePostsState & UsePostsActions
- Estados separados: posts, loading, error
- Função refresh assíncrona
- useEffect com array de dependências vazio para carregamento inicial

================================================================================
DIRETRIZ FINAL DE USO
================================================================================

Este contexto deve ser reutilizado em qualquer workspace, máquina ou projeto futuro de PDM.

Sempre que iniciar um novo código, carregue este arquivo de contexto e siga à risca o padrão do professor, sem adaptações pessoais.

Regras Obrigatórias:
1. Mantenha a arquitetura MVVM com separação rigorosa de camadas
2. Use TypeScript com strict mode
3. Siga exatamente a nomenclatura: camelCase para funções/variáveis, PascalCase para componentes/interfaces
4. Mantenha a ordem: imports → tipos → componente/hook → estilos
5. Use function declarations para hooks e componentes principais
6. Sempre tipar explicitamente (não usar any ou inferência quando possível)
7. Tratamento de erro no ViewModel, não no serviço
8. Estados de loading e error sempre presentes em ViewModels
9. Estilos sempre no final com StyleSheet.create
10. Comentários e textos de UI em português
11. Use async/await, nunca .then()
12. Early returns para estados especiais (loading, error)
13. Nomes descritivos e em português para textos visíveis ao usuário

Não altere o padrão, mesmo que existam alternativas mais modernas ou "melhores práticas" diferentes. O objetivo é manter consistência com o estilo do professor.
